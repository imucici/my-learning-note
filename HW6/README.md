Dijkstra、Kruskal
======

目錄:
--------
* [原理說明](#原理說明)


原理說明:
----

Dijkstra演算法，又稱最短路徑演算法，是用來計算某一個節點到其他所有節點的最短路徑。

核心思想:以起始點為中心向外走訪(廣度優先搜尋的概念)，直到所有節點都被拜訪過為止。


Dijkstra演算法步驟:

首先任選某個節點當作出發點，接著從與其相鄰且尚未走訪過的節點當中，

選出一個與出發點距離最短的節點，把它新增至路徑中(更新最短路徑表)，再接著由此新加入的節點

向外擴展，找尋與其相鄰且尚未走訪過的節點，且距離出發點路徑最短，重複步驟更新最短路徑表，

直到所有的節點都被加入到路徑中。


Dijkstra演算法架構描述:

首先創一個空間用來記錄每個節點到與其相鄰的節點間的距離(透過程式碼中的helper函式做處理)

接著初始化一個array用來記錄已走訪過的節點(程式碼:path)、dict(程式碼:shortest)用來紀錄

起始點到當前節點的最短路徑長、dict(程式碼:previous)用來記錄當前節點的前一個節點、[[]]

(程式碼:pq)用來找出最短路徑的vertex。從起始點開始向外擴展，尋找與其相鄰且未拜訪過的節點

中，距離起始點距離最短的節點，再更新最短路徑表(shortest、previous)--> 此為程式碼中第二個

for迴圈中第一個for迴圈的部分，並且append到pq中，再透過pq找出最短路徑的vertex--> 此為程式

碼中最後一個迴圈的部分。

-----------------------------------------------------------------------------------

Kruskal演算法，又稱最小生成樹演算法，是用來是一種用來尋找最小生成樹的演算法。

什麼是最小生成樹? 

1. 是一顆樹 --> 無迴路、邊數為點數-1。

2. 是生成樹 --> 包含全部頂點、(頂點數-1)條邊都在圖裡。
                 
3. 邊的權重和最小。


Kruskal演算法步驟:

首先將每條邊的權重由小到大排序，每次都先挑選權重最小的那個邊，但要確保挑選到的那個邊如果

加入最小生成樹中時，不會形成loop(若會形成loop則捨棄那條邊)，重複上述挑選步驟，直到最小生

成樹中，有V-1條邊。

Kruskal演算法架構描述:

首先將每條邊的權重由小到大排序(程式碼:arr = sorted(list(zip(self.wet,self.edge))))

-->如此一來，每次就取arr[0]來處理。

另外為了要判斷是否會形成loop，因此要創一個空間紀錄每條邊的root(程式碼:self.root = {})

主程式分為5大情況:

1. 兩個input的root皆為空，統一指定成大的那個的root

2. 小的那個root為空，且大的那個的root存在，把小的那個root指定成大的input的root

3. 大的那個root為空，且小的那個的root存在，把大的那個root指定成小的input的root

4. root皆存在且不相等，把所有root=小的那個改成大的root(先處理非小的那個以外的)

5. root皆存在且相等(會產生loop)，不加入，進行recursive
