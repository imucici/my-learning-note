Heap Sort
===

目錄
-----
* [Binary_Heap_二元堆積](#Binary_Heap_二元堆積)
* [時間複雜度比較](#時間複雜度比較)
* [MaxHeapify](#MaxHeapify)
* [BuildMaxHeap](#BuildMaxHeap)

Binary_Heap_二元堆積:
---

通常用`array`表示，`根節點(root)`index=0，滿足以下兩種特徵:

* `Complete Tree` : 除了最後一層，其他層都是完全的，且最後一層的葉子靠左。

  * index從**0**開始，按照順序填滿位置(如下圖)
  * **parent(父節點)** : 位在`(i-1)//2`
  * **left** : 位在`2*i+1`
  * **right** : 位在`2*i+2`
  
  :laughing: 以index(1)之node(3) 為例，parent為( **1** -1)//2 >> index(0)之node(1) ; left child為 2* **1** +1 >> index(3)之node(5) ; right child為 2* **1** +2 >> index(4)之node(9)
  
  
![圖一](https://www.geeksforgeeks.org/wp-content/uploads/binaryheap.png)

* `Max Heap or min Heap`

  * **Max Heap**： 在每一個subtree中，parent的數值要比left、right的數值`大`
    * array[i] > array[2*i+1]
    * array[i] > array[2*i+2]



  * **min Heap**： 在每一個subtree中，parent的數值要比left、right的數值`小`
    * array[i] < array[2*i+1]
    * array[i] < array[2*i+2]

![Max Heap or min Heap](https://miro.medium.com/max/3076/1*2XhoV0IYgNlRxQ8jCW1Guw.png)

[回目錄](https://github.com/imucici/my-learning-note/blob/master/%E4%B8%8A%E8%AA%B2%E5%85%A7%E5%AE%B9%E7%AD%86%E8%A8%98/%E7%AC%AC%E4%BA%94%E9%80%B1%E4%B8%8A%E8%AA%B2%E9%80%B2%E5%BA%A6.md#%E7%9B%AE%E9%8C%84)



時間複雜度比較:
----

|         |     InsertionSort     | QuickSort  | 	Heap Sort |
| :-------------: |:-------------:| :------------:|:------------:|
| 最佳時間複雜度        | O(n)      | O(nlog n) |Ο(n log n)|
| 平均時間複雜度        | O(n^2)      |   O(nlog n) |Ο(n log n)|
| 最差時間複雜度         | O(n^2)     |  O(n2)   |Ο(n log n)|

[回目錄](https://github.com/imucici/my-learning-note/blob/master/%E4%B8%8A%E8%AA%B2%E5%85%A7%E5%AE%B9%E7%AD%86%E8%A8%98/%E7%AC%AC%E4%BA%94%E9%80%B1%E4%B8%8A%E8%AA%B2%E9%80%B2%E5%BA%A6.md#%E7%9B%AE%E9%8C%84)

MaxHeapify:
----

BuildMaxHeap:
---
